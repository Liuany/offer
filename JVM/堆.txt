【关于堆】
  ①堆是数据存储和数据调用的区域，一个JVM实例只存在一个堆内存，堆是内存管理的核心区域。
  ②堆的大小在JVM启动的时候就已经确定了，它是JVM管理的最大的一个内存空间，堆的内存大小可以调节，堆可以处于物理上的不连续但是在逻辑上必须连续。
  ③堆是线程共享的，但是可以在对空间中开辟线程私有的TLAB(Thread Local Alloaction Buffer).
  ④几乎所有的对象实例和数组都分配在堆上，虽然通过逃逸分析可以实现栈上分配，但是HotSpot官方目前并不支持(20210520)，在方法结束后堆中的对象不会被马上清除，它们会在下一次
  GC时根据是否被引用来决定是否被回收，由于栈不存在GC，因此堆是GC执行垃圾回收的重点区域。

【组成】
  JDK 7及之前：新生代/新生区/年轻代(Eden/survivor0/survivor1) + 老年代/养老区/老年区(Tenure) + 永久代(Perm)。
  JDK 8及之后：新生代/新生代/年轻代(Eden/survivor0/survivor1) + 老年代/养老区/老年区(Tenure) + 元空间(Meta)。

  [新生代]
    <组成>：Eden(伊甸园区) + survivor0/from(幸存者0区) + survivor1/to(幸存者1区)。[谁空谁是to]
    <特点>：①几乎所有的对象都是在新生代被new出来的。
    	    ②绝大多数Java对象的销毁都在新生代进行了，"朝生夕死"是很多对象的真实写照。
	    ③Minor GC的工作区域 

  [老年代]
    <特点>：①存储生命周期较长的对象(极端情况下甚至能与JVM的生命周期保持一致)。
            ②Major GC / Full GC的工作区域。

【对象分配过程】
  [Minor GC]：Eden区中空间满仍需创建新的对象时触发，会同时回收Eden区和两个survivor区中的空间。
  [Major GC /Full GC]：当老年代中的内存满时触发，需要注意的是Major GC只会回收老年代中的空间，而Full GC会对整个堆空间进行回收(包括年代和方法区)，若触发Major GC后空间
  仍然不足则会产生OOM(OutOfMemoryError)异常，值得注意的是，在每次放生Major GC/Full GC之前一般会先触发一次Minor GC。
  [notice]：垃圾回收频繁在新生代中发生，很少在老年代发生，几乎不在永久代/元空间中发生。Minor GC发生的速度比Major快10倍以上，STW给用户造成的影响较小。因此程序中应尽量
  避免出现过多的大对象，减少Major GC和Full GC的触发是优化程序的主要途径。

  [常规过程]
    ①new的对象先放到Eden区，此区域有大小限制。
    ②当Eden区的空间被填满，程序仍需要创建新的对象，这时候就会触发一次Minor GC，经过一次Minor GC幸存下来的对象会被存放到to区(完成后to区将变成from区)，新创建的对象在清
    理后的Eden区中存放。
    ③当Eden区再次被填满，将再次触发Minor GC(会同时清理Eden区和两个survivor区)，在Eden区和from区存活下来的对象将被放入到新的to区，新创建的对象存放到清理后的Eden区。
    ④每经过一次Minor GC，幸存下来的对象年龄属性+1(初始为0)，当年龄大于设定的阈值时(默认为15)时survivor区中的对象将晋升至老年代。可以通过-XX:MaxTenuringThreshold=<N>
    进行设置。

  [非常规情形]
    <超大对象>：一般常见于数组和字符串，Eden没有足够的空间存储，这类对象将直接存放在老年代中。
    <提前晋升老年代>：当survivor区中同龄对象所占空间超过survivor空间的一半时，年龄大于或等于年龄将直接晋升老年代，无需等待MaxTenuringThreshold设定的阈值。

【TLAB】
    对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内，这种做法可以避免一系列的线程安全问题，同时还能提升内存分配的吞吐量，我们也将
  这一分配策略称之为快速分配策略。虽然不是所有的对象实例都能在TLAB中成功分配内存，但是TLAB确实是JVM内存分配的首选，一旦TLAB空间分配内存失败时，JVM就会尝试着通过
  使用枷锁机制确保数据操作的原子性，从而直接在Eden区分配内存。
    在默认情况下，TLAB的空间内存非常小，仅占Eden区的1%。当然我们可以使用-XX:TLABWasteTargetPercent来设置TLAB所占Eden空间的占比，但是没有必要。

【分配担保策略】
  在发生Minor GC之前，虚拟机会检查老年代中可用的连续空间是否大于新生代所有对象的空间：
    1>如果大于：本次Minor GC是安全的，直接触发Minor GC
    2>如果小于，则会判断分配担保策略是否生效：
      1)如果HandlePromotionFailure=ture，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象平均打大小：
        ①如果大于，出发Minor GC，但本次Minor GC存在风险。
	②如果小于，触发Full GC.
      2)如果HandlePromotionFailure=false，触发Full GC。
  
  需要说明的是，在JDK6 Update24之后，HandlePromotionFailure这一参数对虚拟机的影响失效了，我们可以默认它的值是true且不可更改。

【逃逸分析】
    随着JIT编译期的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术使得所有对象都分配在堆上变得不那么绝对了。对象几乎都分配在java堆上但有一种情况例外，如果经过逃逸
  分析之后发现一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配。注意我们说的逃逸其主体说的是对象，而不是对象的成员变量或者对象方法中的形参，形参本就不属于该
  对象，因此是必然发生逃逸的。基于逃逸技术分析，可以通过栈上分配、同步省略、标量替换的方式来对代码进行优化。
    <开发小技巧> 能使用局部变量的就不要在方法外定义(成员变量)

【对空间的参数设置】
  -XX:PrintFlagsInitial：查看所有参数的默认初始值
  -XX:PrintFlagsFinal：查看所有参数的最终值(如果进行了自定义设置则会发生改变)
  -Xms:初始堆空间内存(默认为物理空间的1/64)
  -Xmx:最大堆空间内存(默认为物理空间的1/4)
  -Xmn:设置新生代的大小(初始值及最大值)
  -XX:NewRatio:配置新生代与老年代在堆结构占比
  -XX:SurvivorRatio:配置伊甸园区与幸存者去在新生代的结构占比
  -XX:MaxTunringThreshold:设置新生代垃圾最大年龄
  -XX:PrintGCDetails:详细输出GC处理日志 (简略输出：-XX:PrintGC / -verbose:gc)
  -XX:DoEscapeAnalysis:执行逃逸分析
  -XX:PrintEscapeAnalysis:舒服逃逸分析日志
  -XX:ElimitnateAllocation:开启标量替换

【Q1 Major GC和Full GC有什么区别？】
    垃圾清理范围：Major GC只在老年代进行垃圾回收，Full GC则会对整个堆空间进行垃圾回收，包括新生代和方法区。
    触发条件：Major GC只在老年代空间不足时触发，Full GC会在调用System.gc()时(系统建议执行Full GC但不是必然执行)、老年代空间不足、方法区空间不足，通过Minor GC进入老年代
  的对象的平均大小大于老年代可用空间、由Eden及from进入to的对象大于to的空间大小/有survivor区晋升老年代的对象大小大于老年代可用空间时均可触发。
  
【Q2 为什么要把java堆分代？不分代就不能正常工作了吗？】
  分代是为了优化GC性能，不进行分代一样可以正常工作。

【Q3为什么有TLAB？它的作用是什么？】
    堆区域是线程共有的，任何线程都可以访问堆区域的数据，由于实例的创建是十分频繁的，因此可能造成线程不安全的问题，为避免多个线程同时操作同一地址，需要使用枷锁机制，
  这样会影响分配速度，而TLAB技术的实现可以实现快速分配互不干扰。

【Q4如何判断一个对象是否发生了逃逸？】
  当一个对象的方法被定义之后，对象只在方法内部使用，则认为没有发生逃逸。
  当一个对象的方法被定义之后，它被外部的方法所引用，则认为发生了逃逸。例如作为调用参数传递到其他方法中。