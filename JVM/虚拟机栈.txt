【属性】：线程私有，生命周期与线程相同，用于存储java方法的局部变量表、操作数栈、动态链接、方法出口等信息。

【栈帧】：栈的基本储存单位
  <定义>：栈中的数据以栈帧的格式存在，每个栈帧对应一个方法，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。
  <组成>：局部变量表、操作数栈、动态练级、方法返回地址、一些附加信息

<局部变量表>
  ①定义为一个数字数组，主要用于储存方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、引用对象以及returnAdress类型。由于局部变量表是建立在线程的栈
内，因此不存在数据安全问题，其大小从编译期便已确定，不会在程序运行期间发生改变。
  ②局部变量表中的变量只在当前方法中有用，当方法调用结束后，随着方法栈(栈帧)的销毁，局部变量表也会随之销毁。
  ③局部变量表的index从0开始，一般在index为0的位置存储this对象，局部变量表的存储单位是slot(插槽)，32位以内的类型只占用一个slot,64位的类型占用两个slot(如long、double)
JVM会为每个slot分配一个访问索引，通过索引可以访问到局部变量变中的值，值得注意的是，槽位是可以重复利用的，当一个局部变量过了其作用域，那么其作用域之后申明的新变量将复
用已过期的局部变量表的槽位，从而达到节省资源的目的。
  ④由于局部变量表不存在系统初始化的过程，因此必须给局部变量进行认为赋值才能使用。
  ⑤局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量变中直接或间接引用的对象都不会被回收。

<操作数栈>
  ①也称之为表达式栈，遵从后进先出(Last-In-First-Out LIFO)的原则，其作用是根据字节码指令往栈中写入或提取数据(即入栈/出栈)。
  ②用于保存计算过程的中间结果，同时为计算过程提供临时存储空间，拥有明确的栈深度用于存储数值，其最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值
  ③操作数栈是JVM执行引擎的一个工作区，当一个方法被创建时，一个新的栈帧也会随之被创建，此时该方法的操作数栈是空的
  ④JVM多用数组的结构来实现操作数栈，但这并不意味着我们可以用索引的方式来访问操作数栈，操作数栈只能通过入栈(push)和出栈(pop)的形式进行一次数据访问，严格遵循后入先出
  的原则。
  ⑤如果被调用的方法带有返回值的话，其返回值会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
  [栈顶缓存技术]
  为什么需要栈顶缓存技术呢？我们知道由于栈式架构的虚拟机所使用的零地址虽然使指令变得更加紧凑，但这意味着完成一项操作需要更多的入栈和出栈指令，这意也就意味着需要分派
  更多次数的内存读/写次数，这将降低程序运行的性能。为了解决这一问题，栈顶缓存技术应运而生，设计者们将栈顶元素全部缓存进物理cup的寄存器中，以此降低了内存的读/写次数
  提升了执行引擎的效率。

<动态链接>
  ①每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，这是实现动态链接的基础，动态链接的目的就是为了将这些符号引用转换为调用方法的直接引用。
  [方法的调用]：方法是何种方法？是用什么方式链接？在什么时候进行绑定？
  静态链接：目标方法在编译器可知，且在运行期保持不变，该情况下将调用方法的符号引用转换为直接引用
  动态链接：目标方法在编译器不可知，只能在运行期将调用方法的符号引用转换为直接引用，这种引用的转换具备动态性
  #绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程这个过程仅仅发生一次#
  早起绑定：目标方法在编译器可知，且在运行期保持不变，静态链接使用这种方式
  晚期绑定：目标方法在编译器不可知，只能在运行期将调用方法的符号引用转换为直接引用，动态链接使用这种方式
  非虚方法：如果方法在编译器就确定了具体的调用版本，且这个版本在运行时是不可变的，这样的方法称之为虚方法(如静态方法、私有方法、final方法，实例构造器方法、父类方法)
  虚方法  ：除非虚方法的其他方法统称为虚方法

  invokestatic:调用静态方法，解析阶段确定唯一版本
  invokespecial:调用<init>方法，私有及父类方法，解析阶段确定唯一版本
  invokevirtual:调用所有虚方法，需特别留意调用final方法时也会使用该指令，但final方式为非虚方法
  invokeinterface:调用接口方法

<方法返回地址>
  ①存放调用该方法的pc寄存器的值
  ②一个方法的结束，有两种方式：
    1> 正常执行完成 (执行引擎遇到任何一个方法返回的字节指令[return]，会有返回值传递给上层调用者)
    2> 出现未处理的异常，非正常退出 (异常处理器储存在异常处理表中，遇到异常且未能在异常处理表中搜索到相对应的异常处理器从而导致的退出)
      无论以那种方式退出，在方法退出后都会回到该方法被调用的位置。方法正常退出时，调用者的pc寄存器的值作为返回地址，及调用该方法的指令的下一条指令的地址。而通过异常退
    出的，需要通过异常表来确定，栈帧中一般不会保留这部分信息。
  ③方法的退出本质上就是出栈的过程。此时，要恢复上层方法的局部变量、操作数栈、将返回值压入调用者的操作数栈、设置pc寄存器的值等，让调用者方法继续执行下去。
  常用返回字节指令：
  ireturn：返回值为bollean,byte,short,char和int时
  lreturn：返回值为long时
  freturn：返回值为float时
  dreturn：返回值为double时
  areturn；返回值为实例引用时

<一些附加信息>
  栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如对程序调试提供支持的信息。

【Q1】虚拟机栈有哪些优缺点？
  虚拟机栈也称作java栈，优点是跨平台，指令集小，编译容易实现；缺点是性能下降，实现同样的功能需要更多的指令

【Q2】虚拟机栈与堆的区别：
  栈是运行时的单位，解决的是程序运行时的问题，即程序如何执行，或者说如何处理数据；堆是存储单位，解决的是数据存储的问题，即数据放在哪？怎么放？

【Q3】什么是虚拟机栈？
  Java虚拟机栈(Java Virtual Machine Stack)早起也称作Java栈，每个线程创建时都会创建一个虚拟机栈，其内部保存一个个栈帧(Stack Frame)，对应着一次次方法的调用。虚拟机栈随着
线程的创建而创建，随着线程的消亡而消亡(生命周期与线程一致)，它主管程序的运行，保存方法的局部变量及部分结果，并参与方法的调用和返回。

【Q4】栈的大小是否能调整？常见的异常有哪些？这些异常会在什么情况下发生？
  栈的大小决定了函数调用最大可达深度，栈的大小是可以被调整的，可以通过-Xss来设置栈的大小，但是栈的大小并不是越大越好，即便将栈的大小设置得很大也无法保存不会引发异常的
发生。栈可以设置成动态的或是固定不变，当线程请求分配的容量超过固定最大容量时会抛出StackOverFlowError异常，若设置为动态容量，栈可以动态扩展，若栈无法申请到足够的内存
时会出现OutOfMemerry异常。

【Q5】为什么需要常量池呢？
  常量池的作用，就是为了提供一些符号和常量，便于指令识别。

【Q6】方法正常完成出口与异常完成出口有什么区别？
  通常方法异常完成出口退出的不会给他的上层调用者产生任何的返回值。

【Q7】举出栈异常的情况
  StackOverFlowError/OutOfMemery

【Q8】调整栈的大小就能保证不出现溢出吗？
  不能

【Q9】分配的栈内存越大越好吗？
  对栈本身来说是越大越好，但是对整个程序来说不是

【Q10】垃圾回收是否会设计虚拟机栈？
  不会，虚拟机栈属于线程私有，其生命周期与线程保持一致，随着线程的消亡而消亡，因此不存在垃圾回收。

【Q11】方法定义的局部变量是线程安全的吗？
  具体问题具体分析，若改局部变量为方法私有则为线程安全，若不是局部私有(如成员变量、形参、返回值等)则不是线程安全的。