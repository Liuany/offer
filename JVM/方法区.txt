【概念】
    方法区从逻辑上是属于堆的一部分，但实际上又是独立于堆空间的部分，在HotSpot中为了区别堆和方法区，特意用了No-Heap(非堆)来给方法区命名，我们可以把方法区看做是一块独立
  于堆的内存空间。和Java堆一样，方法区属于线程共享，方法区在JVM启动时被创建，其大小可以选择是固定的也可以选择是可拓展的，其内存空间同Java堆一样可以是不连续。由于方法
  区主要存储的是类的信息，因此方法区的大小决定了系统可以定义类的多少，如果系统定义了太多的类，则会产生OutOfMemoryError异常。关闭JVM会释放这部分内存。

【演进】
    在JDK8以前，习惯上把方法区称为永久代(Permanet Generation)，JDK8则使用元空间(Meta Space)替换了永久代。元空间与永久代类似，都是对JVM规范中方法区的实现，它们最大的
  区别在于元空间不再设置在内存中，而是使用本地内存(在Oracle获得了JRockit虚拟机后进行了这次调整)。
    JDK6：有永久代，静态变量及字符串常量放在方法区中，其中字符串常量放在运行时常量池中。
    JDK7：有永久代，静态变量及字符串常量都放在堆空间中。
    JDK8：永久代被元空间替代，但静态变量及字符串常量都放在堆空间了(元空间几乎不会进行垃圾回收，将静态变量及字符串常量放在堆空间中便于垃圾回收)

【设置方法区内存大小】
  JDK8以前：-XX:PermSzie 设置永久代初始空间大小，默认20.75M  -XX:MaxPermSize 设置永久代最大可分配空间，32位默认64M，64位默认82M
  JDK8及以后：-XX:MetaSzie 设置元空间初始空间大小，windows默认21M  -XX:MaxPermSize 设置元空间最大可分配空间 (设置值为-1时表示不设置上限)
    --这里需要注意初始的高水位线问题，如windows下默认元空间的高水位线为21M，一旦触及这个高水位线则会重置高水位线，新的高水位线取决于GC后释放了多少空间，在不触及
    MaxPermSize的前提下，适当提高该值。如果释放的空间过多，则降低该值。
  [内存泄漏] 对象已经不被使用了，但是还是存在与GC Roots相关联，从而导致垃圾收集器无法回收这部分内存导致内存不足。
  [内存溢出] 对象是必须活着的，单纯的内存不足。

【栈、堆、方法区交互关系】
  Person person = new Person()
  方法区 Java栈   Java堆
    在上述例子中，[Person]代表的是类型，类信息存放在方法区中，[person]是方法中定义的一个局部变量，因此这部分为存放在Java栈的局部变量表中的一个对象引用，它指向堆中一个
  具体的实例。[new Person()]即为这个具体的实例，它存放在堆空间中(注意new的对象无论哪种情况都是存放在堆空间中的)，而在每个实例的首地址又存在着一个指针指向方法区中该实
  例对应的类信息，实例通过这种形式获取对象类型数据。


【方法区的内部结构】 类信息 + 常量 + 静态变量 + 即时编译器编译后的代码缓存 + 域信息 + 方法信息等
  ①类信息(包含class,interface,enmu,annotation)：完整有效名称(全面=包名+类名)、父类完整有效名、这个类型的修饰符、类型直接接口的有序列表。
  ②域信息：域名称、域类型、域修饰符(pulic/private/void/static/final/volatitle/transient的某个子集)。
  ③方法信息：方法名称、方法返回类型、方法修饰符、方法的字节码、异常表。
  ④静态变量：静态变量和类关联在一起，随着类的加载而加载，类的变量被所有实例共享，即便没有类的实例你也可以访问它。
  ⑤全局常量：在编译器就被分配了值，不可改变。
 
【常量池与运行时常量池】
    常量池：一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池(Constant Pool Table)，包含各种字面量的对类型、方法、
  域的符号引用。常量池的组成包含数量值、字符串引用、类引用、字段引用、方法引用，可以将常量池看做一张表，虚拟机指令根据这张表找到执行的类名、方法名、参数类型、字面量
  等类型。
    运行时常量池：运行池常量池是方法区的一部分，是class文件的常量池表加载到方法区后创建。JVM会为每个已加载的类型，池中的数据像数组一样，通过索引访问。运行时常量池中
  包含多种不同的常量，包括编译期就已经明确的数值和字面量，也包括到运行期解析后才能获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换成了真是地址。相对于常
  池，运行时常量池一个重要特性是动态链接。

【方法区的垃圾回收】
  [常量]：字面量和符号引用：①类和接口的权限定名  ②字段的名称和描述符  ③方法的名称和描述符
    只要常量池中的常量没有被任何地方引用，就可以回收。

  [类型]
    ①该类所有的实例都已经被回收，也就是说Java堆中不存在该类及其任何派生

【Q1】如何解决方法区的OOM？
    首先利用内存映射工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否必要，也就是要确定是内存泄漏还是内存溢出。如果是内存泄漏，则进一步通过工具检查
  GC Roots的引用链，找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收这部分内存的。掌握了内存泄漏对象的类型信息，以及GC Roots引用链的信息，
  就可以比较准确地定位出内存泄漏的位置，从而进行处理。
    如果不存在内存泄漏，则说明内存中的对象都还必须是活着的，可以通过修改虚拟机堆的参数与物理内存进行对比看是否还可以调大，从代码上检查是否存在一些生命周期过长，持
  有状态过久的情况，尝试减少程序运行时的内存消耗。

【Q2】为什么需要常量池？
    Java源文件生成的字节码文件被加载JVM中运行时需要数据的支持，通常这样的数据非常大不能直接存储在字节码文件里，但是可以存到常量池，这个字节码包含了指向常量池的引用，
  在动态链接时会用到运行时常量池。

【Q3】永久代为什么要被元空间替换？
  ①为永久代设计空间大小非常难确定，在某些场景下如果加载的类过多而永久代的空间不够的话容易产生Perm的OOM，使用元空间的话其空间大小仅受本地内存大小限制。
  ②对永久代进行调优十分困难，因为类的回收机制十分苛刻。

【Q4】为什么要将字符串常量(String Table)放到堆空间中(JDK7发生的变化)
    这么做的目的是为了提高垃圾回收效率。因为永久代的回收效率很低，Full GC只会在老年代、永久代空间不足时才会触发，这就导致String Table的回收率不高，在开发中有大量字符
  串被创建，如果将这部分数据都存在在永久代则容易引发永久代内存不足。放到堆里则能及时回收。